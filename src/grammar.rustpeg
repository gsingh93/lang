use super::{Program, FnDecl, Block, Stmt, Expr, BinOp, Type, ArgList, Variable};
use Expr::{True, False, Num, BinExpr, EmptyExpr, IdentExpr, FuncCallExpr};
use Stmt::{DeclStmt, ExprStmt, ReturnStmt, AssignStmt};
use Type::{IntTy, StringTy, UserTy};
use BinOp::{AddOp, SubOp, MulOp, DivOp};
use std::i32;

#[pub]
program -> Program
    = __ func_decls:func_decl* { Program { fns: func_decls } }

func_decl -> FnDecl
    = ty:type name:ident lparen args:arg_list rparen b:block {
        FnDecl { ty: ty, name: name, args: args, block: b }
    }

type -> Type
    = "int" __ { IntTy } / "string" __ { StringTy } / name:ident { UserTy(name) }

variable -> Variable
    = ty:type name:ident { Variable { ty: ty, name: name } }

arg_list -> ArgList
    = vars:variable ** comma { ArgList{ args: vars } }

block -> Block
    = lbrace s:stmt* rbrace { Block { stmts: s } }

stmt -> Stmt
    = decl_stmt / expr_stmt / return_stmt / assign_stmt

decl_stmt -> Stmt
    = var:variable equals e:expr semicolon {
        DeclStmt(var, e)
    }

expr_stmt -> Stmt
    = e:expr semicolon {
        ExprStmt(e)
    }

return_stmt -> Stmt
    = return e:expr semicolon {
        ReturnStmt(e)
    }

assign_stmt -> Stmt
    = name:ident equals e:expr semicolon {
        AssignStmt(name, e)
    }

expr -> Expr
    = t:term e:bin_expr_ {
        match e {
            EmptyExpr => t,
            BinExpr(box EmptyExpr, op, e2) => BinExpr(Box::new(t), op, e2),
            _ => panic!("Got unexpected expression {:?}", e)
        }
    }

bin_expr_ -> Expr
    = bin_expr / __ { EmptyExpr }

term -> Expr
    = true { True } / false { False } / num / name:ident e:func_or_ident_expr {
        match e {
            EmptyExpr => IdentExpr(name),
            FuncCallExpr(_, params) => FuncCallExpr(name, params),
            _ => panic!("Got unexpected expression {:?}", e)
        }
    }

func_or_ident_expr -> Expr
    = lparen params:param_list rparen { FuncCallExpr("".to_string(), params) }
    / __ { EmptyExpr }

param_list -> Vec<Expr>
    = expr ** comma

bin_expr -> Expr
    = op:bin_op e2:expr __ {
        BinExpr(Box::new(EmptyExpr), op, Box::new(e2))
    }

num -> Expr
    = n:([0-9]+ {match_str.parse().unwrap()}) __ {
        if n > i32::MAX {
            panic!("Integer literal {} too large", n)
        }
        Num(n)
    }

bin_op -> BinOp
    = '+' __ { AddOp } / '-' __ { SubOp } / '*' __ { MulOp } /  '/' __ { DivOp }


ident -> String
    = name:(letter [a-zA-Z0-9_]* { match_str.to_string() }) __ { name }

letter -> char
    = [a-zA-Z] { match_str.char_at(0) }


return = "return" __
true = "true" __
false = "false" __
semicolon = ';' __
lparen = '(' __
rparen = ')' __
lbrace = '{' __
rbrace = '}' __
equals = '=' __
comma = ',' __

__ = (whitespace / eol / comment)*

comment
  = singleLineComment
  / multiLineComment

singleLineComment
  = "//" (!eolChar .)*

multiLineComment
  = "/*" (!"*/" .)* "*/"

eol
  = "\n"
  / "\r\n"
  / "\r"

eolChar
  = [\n\r]

whitespace
  = [ \t]
