use super::{Program, FnDecl, Block, Stmt, Expr, BinOp, Type, ArgList, Variable};
use Expr::{True, False, Num, BinExpr, EmptyExpr, IdentExpr, FuncCallExpr};
use Stmt::{DeclStmt, ExprStmt, ReturnStmt, AssignStmt, IfStmt, WhileStmt};
use Type::{IntTy, StringTy, UserTy};
use BinOp::{AddOp, SubOp, MulOp, DivOp, LessOp, GreaterOp, EqualsOp};
use std::i32;

#[pub]
program -> Program
    = __ func_decls:func_decl* { Program { fns: func_decls } }

func_decl -> FnDecl
    = ty:type name:ident lparen args:arg_list rparen b:block {
        FnDecl { ty: ty, name: name, args: args, block: b }
    }

type -> Type
    = "int" __ { IntTy } / "string" __ { StringTy } / name:ident { UserTy(name) }

variable -> Variable
    = ty:type name:ident { Variable { ty: ty, name: name } }

arg_list -> ArgList
    = vars:variable ** comma { ArgList{ args: vars } }

block -> Block
    = lbrace s:stmt* rbrace { Block { stmts: s } }

stmt -> Stmt
    = return_stmt / assign_stmt / if_stmt / while_stmt / decl_stmt / expr_stmt

decl_stmt -> Stmt
    = var:variable equals e:expr semicolon {
        DeclStmt(var, e)
    }

expr_stmt -> Stmt
    = e:expr semicolon {
        ExprStmt(e)
    }

return_stmt -> Stmt
    = return_kw e:expr semicolon {
        ReturnStmt(e)
    }

assign_stmt -> Stmt
    = name:ident equals e:expr semicolon {
        AssignStmt(name, e)
    }

if_stmt -> Stmt
    = if_kw e:expr b1:block b2:(else_kw b:block { b })? { IfStmt(e, b1, b2)}

while_stmt -> Stmt
    = while_kw e:expr b:block { WhileStmt(e, b) }

expr -> Expr
    = t:term e:bin_expr_ {
        println!("got term {:?}", t);
        match e {
            EmptyExpr => t,
            BinExpr(box EmptyExpr, op, e2) => BinExpr(Box::new(t), op, e2),
            _ => panic!("Got unexpected expression {:?}", e)
        }
    }

bin_expr_ -> Expr
    = bin_expr / __ { EmptyExpr }

bin_expr -> Expr
    = op:bin_op e2:expr __ {
        BinExpr(Box::new(EmptyExpr), op, Box::new(e2))
    }

term -> Expr
    = true_kw { True } / false_kw { False } / num / name:ident e:func_or_ident_expr {
        match e {
            EmptyExpr => IdentExpr(name),
            FuncCallExpr(_, params) => FuncCallExpr(name, params),
            _ => panic!("Got unexpected expression {:?}", e)
        }
    }

func_or_ident_expr -> Expr
    = lparen params:param_list rparen { FuncCallExpr("".to_string(), params) }
    / __ { EmptyExpr }

param_list -> Vec<Expr>
    = expr ** comma

num -> Expr
    = n:([0-9]+ {match_str.parse().unwrap()}) __ {
        if n > i32::MAX {
            panic!("Integer literal {} too large", n)
        }
        Num(n)
    }

bin_op -> BinOp
    = add_tok { AddOp } / sub_tok { SubOp } / mul_tok { MulOp } / div_tok { DivOp }
    / lt_tok { LessOp } / gt_tok { GreaterOp } / eq_tok { EqualsOp }


ident_char -> char
    = [a-zA-Z0-9_] { match_str.char_at(0) }

ident -> String
    = name:(letter ident_char* { match_str.to_string() }) __ { name }

letter -> char
    = [a-zA-Z] { match_str.char_at(0) }

add_tok = '+' __
sub_tok = '-' __
mul_tok = '*' __
div_tok = '/' __
lt_tok = '<' __
gt_tok = '>' __
eq_tok = '==' __
return_kw = "return" kw__
true_kw = "true" kw__
false_kw = "false" kw__
if_kw = "if" kw__
else_kw = "else" kw__
while_kw = "while" kw__
kw__ = (!ident_char) __

semicolon = ';' __
lparen = '(' __
rparen = ')' __
lbrace = '{' __
rbrace = '}' __
equals = '=' __
comma = ',' __

__ = (whitespace / eol / comment)*

comment
  = singleLineComment
  / multiLineComment

singleLineComment
  = "//" (!eolChar .)*

multiLineComment
  = "/*" (!"*/" .)* "*/"

eol
  = "\n"
  / "\r\n"
  / "\r"

eolChar
  = [\n\r]

whitespace
  = [ \t]
